[Random Thoughts 15 years into Software Engineering](https://roughlywritten.substack.com/p/random-thoughts-15-years-into-software)

Debuggability is highly underrated. When writing code, you have to think about how it will execute. You also need to be thinking about how it will fail and how you will debug it *in production*. Leave yourself audit trails, store data in human readable formats, and invest in admin tooling.


[Habits of great software engineers](https://vadimkravcenko.com/shorts/habits-of-great-software-engineers/)

    Focusing beyond the code - as a developer you will code 20% of your time. You should excel at coding nonetheless, but it won't be enough to be great.
    Efficiency / Antifragility — Making sure everything around you runs smoothly and has forward momentum
    Joy of tinkering - build projects, try out frameworks, build stuff on the side. Keeps the spark alive.
    Knowing the why — It's important to know why your code does what it does, too many abstractions nowadays that rarely someone thinks below the level of their language e.g JS devs not thinking about the engine that runs their code.
    Thinking in systems — knowing how your code impacts not only your individual system but other parts of the business/application/life.
    Tech detox — Recharging away from your monitor makes you a better programmer.
    The art of approximation — Knowing important tech numbers to approximate calculations when making decisions when programming.
    If this sounds interesting there's a few more things like that at the bottom. But you'll have to read it.


[Drunk Post: Things I've learned as a Sr Engineer](https://www.reddit.com/r/ExperiencedDevs/comments/nmodyl/drunk_post_things_ive_learned_as_a_sr_engineer/)

[40 years of programming](https://liw.fi/40/)

Interesting and significant software is beyond the capacity of any one person to build alone in a reasonable time frame. This means that the fundamental, crucial, core skills in building software are communication and collaboration.
You also need to know how to talk with other people to learn what software to build, what it must do, how much effort is acceptable, how to manage the work, and many more things. 

Even in the projects where I'm the only person, there are at least three people involved: past me, present me, and future me.

---

It is widely considered, in the software industry, that most of the cost of software production comes after the initial release, in the so called maintenance phase. The initial development might take a year or two, maintenance will take decades.

One would think that this would lead to development practices, and architectural decision, and everything else to be optimized for lower maintenance costs. Unfortunately, the economic and other incentives favor the opposite.

It's on individual developers to try to reduce maintenance costs surreptitiously, when they can, as a kind of preemptive guerrilla maintenance.

---

Detailed planning beyond the very near future is difficult and usually fails. This includes estimating how long the work will take. I avoid doing this.

Planning and estimation are far from useless and should not be neglected. 

---

When making a change, make only one change at a time.

[(A few) Ops Lessons We All Learn The Hard Way](https://www.netmeister.org/blog/ops-lessons.html)

[How to Build Software like an SRE — willett dot io](https://www.willett.io/posts/precepts/)

Never give up on local testing. It keeps dev cycle time much shorter than needing to rely on (and fiddle with) CI or remote workspaces. Containerizing the local test environment can make it easier to keep dependencies straight and consistent across machines.

Use Git. Use it for everything – infrastructure, configuration, code, dashboards, on-call rotations. Your git repository is your point-in-time-recoverable source of truth.

[General guidance when working as a cloud engineer](https://www.lockedinspace.com/posts/001.html)

Before jumping straight into a new technology, read and understand their docs. Eventually, it will save you time and lots of headaches. E.g: If you want to learn a new language, you should first understand the basic blocks of that technology such as (data types, interpolations, variables, assignments, etc.)

A good monitoring system, well-organized repository, fault-tolerance workloads and automation mechanisms are the basis of any architecture.

When bad things happen, remember that a wider view is your best ally.

[An Old Hacker's Tips On Staying Employed - The Mad Ned Memo](https://madned.substack.com/p/an-old-hackers-tips-on-staying-employed)

## Develop your personal brand

Brand loyalty is a thing, and even if you do not slavishly follow it, you are probably at least somewhat likely to return to something you know is of good quality than take a risk on something unknown.

Personal brand also works like that. When you work on a project, even a crappy project, your personal brand is on display for all potential shoppers to see. And even when everything is going south, others will notice which people are easy to work with, which people can be relied upon to do what they said they would do, and which people consistently produce a quality result.

## Make Your Boss Afraid

Afraid of what will happen, if you ever decide to leave.

## Make Your Boss Happy

What it means is, putting yourself in your boss’s shoes, and thinking about what they need to be able to succeed in their boss’s eyes.

Give your boss stuff they can use. Maybe it’s ideas and suggestions about how to frame or present work the group has done, or explain problems you have faced. Maybe it’s a little bit of bonus content from time to time, that can be highlighted in a status report. Maybe it’s helping to defuse a situation that would make your boss or the group look bad. Sometimes it takes a little imagination to put yourself in your boss’s place, or maybe even some investigation on your part to find out what your boss’s true care-about’s really are, but this is worthwhile to do in general, anyway.

When your boss takes credit for your work, it is usually (unless you have an awful boss, anyway) done in a way that helps him or her, while simultaneously raising your visibility in the company, and improving your personal brand. 

## The “Do It Anyway” Principle

Two categories of people:

1. Those who were vocal about their frustrations and frequently cited the environmental issues as reasons for delayed or unfinished tasks.
2. Those who found ways to succeed and complete their assigned tasks anyway, despite the constraints imposed by the poor work environment.

Adopting a mindset of treating obstacles as unnecessary challenges to overcome, almost like games. This mindset helped them push through difficult situations.

Regardless of external factors hindering productivity, employees are still measured and evaluated based on what they deliver. Those who can find ways to succeed despite adversity will have an advantage over those who cannot or choose not to.

## Two and Done

The "Two-And-Done" rule is about giving yourself two chances to make your case on a disagreement:

1. State your viewpoint and reasoning the first time.
2. If not accepted, make your case again a second time, perhaps rephrasing or refining your argument.

If you fail to convince others after the second attempt, gracefully concede and get behind the agreed-upon decision. Don't undermine or sabotage it.If you fail to convince others after the second attempt, gracefully concede and get behind the agreed-upon decision. Don't undermine or sabotage it.

Be effective rather than stubbornly trying to always be right. 

[My First Year as a Data Scientist](https://codebuildrepeat.blogspot.com/2020/03/my-first-year-as-data-scientist.html)

Use databases instead of flat files.

Give more presentations.  Presentations have four audiences:

- devs, stakeholders, other departments and external.

Need to think about the audience.

Answer the question the stakeholder is answering.

[Advice That Actually Worked For Me](https://nabeelqu.co/advice)

## Maximize baseline energy levels

Energy compounds on itself.

Most people’s mental models of energy are flawed: they think there’s a ‘tank’ of energy that gets depleted as you spend it. This may be roughly true for physical energy, but mental energy is different: spending mental energy on things that you consider productive or important gives you more mental energy for other things: a positive feedback loop. On the other hand, procrastinating, spending all day scrolling Twitter, or staying in bed all day reduces the amount of energy you have to spend; this means you are less likely to get anything done.

## Do the most important thing first thing in the morning, and don’t check social media until you’ve done it

## Tell the right stories about yourself

If you tell yourself you’re very energetic person, that feeling tired is temporary, and you keep this belief going, you actually become more energetic.

## Don't sleep too much

## Get in the habit of Fermi estimation, looking up key quantities, and using upper and lower bounds. 

I’ve noticed a lot of the smartest people I know do this: they don’t take any claims at face value, and check for themselves whether they’re plausible. This means, e.g. when they hear a fact, they’ll look it up to assure themselves that it’s true, because often people cite things that are false or partial. 

 Engineers and physicists are trained to do this, everyone else has to learn. The usual name for this is Fermi estimation: estimating the rough order of magnitude of an unknown quantity using information that you already know. 

## Whenever you make a claim or an argument, try and imagine the strongest possible argument against it

## Write regularly, and learn to ‘think in writing’

## Do a weekly review

## Synthesize things as you read. 

Just because you’ve read something, doesn’t mean you’ve understood it; your brain has to come up with its own encoding. Whatever understanding things is, it’s related to compression. Which implies that you want to read and then restate in your own words, so that your mind is forced to compress the thing. Ideally several times, in varying ways.

Once you’ve done this, you are much more likely to retain the thing, and to actually grasp it; and if you’re struggling with this exercise, then you don’t understand the thing and should go back and look at it again. (This is also a useful bullshit filter -- try and restate someone’s claim in a different way, and see if it still holds up). 

## Map out problems using logic trees

This is a classic problem-solving and brainstorming technique, also known as morphological analysis. It’ll be familiar to any consultant, as it’s 80% of their secret sauce.  

Take a problem, say analyzing a business’s profits (as in consulting). Break it down into logically exhaustive possibilities, e.g. “revenue” and “costs”. Break down each branch further into its component parts, e.g. revenue becomes price * quantity. Follow this process recursively, each time breaking the tree down into components.

Now you have a full map of the possibilities and can start to answer questions like “how do we increase profits?” by listing out all available options. This often helps you spot options that other people will overlook.


[136 facts every web dev should know before they burn out and turn to landscape painting or nude modelling – Baldur Bjarnason](https://www.baldurbjarnason.com/2021/100-things-every-web-developer-should-know/)

There are exceptions to most rules.

One of the biggest problems in web development, specifically and software development in general, is failure demand. “Failure demand is demand caused by a failure to do something or do something right for the customer." (John Seddon, 2003).

Sturgeon’s law applies to your work as well. Don’t linger on one project forever. Make new things. That’s the only way to learn.

The trick is to recognise when it’s time to move on.

Minimalism is garbage. Simplicity is great, but minimalism sucks. Everything you see on the screen should have a reason to be there (be an embodiment of ‘doing’), but if the reasons are complicated, then the design should represent that complexity. Hiding complications makes everything harder, and excessive minimalism is just as harmful as excessive decoration.

Try to write your CSS in layers.

    A settings stylesheet that collects all of your base variables.
    A base stylesheet that serves as the foundation.
    Layout stylesheets. Each one should implement a layout or composition without depending on other stylesheets.
    Block stylesheets that are the motif to your composition, the phrases in your structure, the recurring themes of your design.
    And the utilities that do one thing and one thing only.

Only use the ID selector in your CSS as a last resort to fix extreme and hard-to-solve specificity issues. Try doubling up on a class first. .class.class is a valid selector and can work wonders.

Dependencies suck; dependencies rule. Other people’s code is like getting other people’s work for free. The downside is that it comes with their opinions, hobbies, and hygiene attached. All code comes bundled with a code smell. Usually, there isn’t anything you can do to prevent it from stinking up the place.

Most ‘innovative’ tech startups face what I like to call ‘the clear field problem’. Whenever you have an app or business idea that nobody else seems to have done successfully before, it’s never because you are particularly clever or original. It’s always because everybody else who has tried is now dead in a ditch somewhere (metaphorically speaking).

Any field with multiple successful competitors is good news. It means that there is demand, which you can tap in by addressing the problem in your way. In a sector with solid margins, this is an opportunity for design innovation to shine.

Any field where all of the other competitors are free services, outdated desktop apps, open-source communities with no revenue, or wannabe startup cults burning through cash is a lethal minefield covered in a cloud of mustard gas.

Trust is a recurring theme when it comes to teamwork. Clear communications and trust will smooth over a lot of fuck-ups.

A good manager will structure the organisation and processes so that the workers' needs, when fulfilled, will result in them being able to meet the customer’s needs.

A bad manager will churn through employees like tissue paper, sacrificing their well-being for vague and distant business goals.

The worst manager sacrifices their well-being as well as their employees' well-being.

[The perils of constant feedback](https://blog.tjcx.me/p/the-perils-of-constant-feedback)

> I worry that the deluge of instant, high-fidelity feedback is driving us toward local minima. Usually feedback encourages us to move down the path of least resistance, to make the easiest gains—but often the best gains are made by walking uphill for bit.

> There is a time for lots of feedback (when you’re close to your goal) but there’s also a time for charging ahead, Twitterverse be damned.

[The Importance of Humility in Software Development](https://humbletoolsmith.com/2020/08/10/the-importance-of-humility-in-software-development/)

[Rob Pike's 5 Rules of Programming](https://users.ece.utexas.edu/~adnan/pike.html)


    Rule 1. You can't tell where a program is going to spend its time. Bottlenecks occur in surprising places, so don't try to second guess and put in a speed hack until you've proven that's where the bottleneck is.

    Rule 2. Measure. Don't tune for speed until you've measured, and even then don't unless one part of the code overwhelms the rest.

    Rule 3. Fancy algorithms are slow when n is small, and n is usually small. Fancy algorithms have big constants. Until you know that n is frequently going to be big, don't get fancy. (Even if n does get big, use Rule 2 first.)

    Rule 4. Fancy algorithms are buggier than simple ones, and they're much harder to implement. Use simple algorithms as well as simple data structures.

    Rule 5. Data dominates. If you've chosen the right data structures and organized things well, the algorithms will almost always be self-evident. Data structures, not algorithms, are central to programming.

Pike's rules 1 and 2 restate Tony Hoare's famous maxim "Premature optimization is the root of all evil." Ken Thompson rephrased Pike's rules 3 and 4 as "When in doubt, use brute force.". Rules 3 and 4 are instances of the design philosophy KISS. Rule 5 was previously stated by Fred Brooks in The Mythical Man-Month. Rule 5 is often shortened to "write stupid code that uses smart objects". 

[What I Wish Someone Had Told Me - Sam Altman](https://blog.samaltman.com/what-i-wish-someone-had-told-me)

audacious ideas motivate people.

Long-term orientation is in short supply

Concentrate your resources on a small number of high-conviction bets

Fast iteration can make up for a lot; it’s usually ok to be wrong if you iterate quickly. Plans should be measured in decades, execution should be measured in weeks.

[Learnings from 5 years of tech startup code audits](https://kenkantzer.com/learnings-from-5-years-of-tech-startup-code-audits/)

- don't need 100's of engineers (can be small + mighty)
- simple better than smart
- bad security vulnerabilities are often obvious
- JWT auth can be hard to get right

[My guiding principles after 20 years of programming](https://alexewerlof.medium.com/my-guiding-principles-after-20-years-of-programming-a087dc55596c) [HN Discussion](https://news.ycombinator.com/item?id=30763516)

```
usrbinbash

> Never start coding (making a solution) unless you fully understand the problem.

While I agree with this in general, I find that to reall fully understand a problem, I need to attempt to code, or at least formulate, a solution to it.

a) because when I break down a problem into its code-able component parts, I learn a lot about it

b) because in the process of then actually implementing these parts I often discover edge cases or undefined cases (especially in naturally grown business-logic)

c) because what the problem actually IS, is often not that clear at the start of the problem. Yes, in an ideal world, changing requirements would wait until the next version, however, sadly that's not what happens in the wild. 

    JKCalhoun 

    Yeah, it could just be me, but I prefer to make two false starts, toss them, and then get it right on the third attempt rather than attempting to whiteboard the problem for two weeks.

    Not only is it more interesting to me to try three different ways to tackle a problem, but I have been burned when the two weeks of whiteboarding missed something and I'm back to having to iterate anyway.

    To be sure, I do a little whiteboarding, but generally it might be about 2 hours or so of sketching out ideas, major structures, code flow ideas.

        Palomides 

        I forget where I read this, but something like:

        first time to understand the problem

        second time to understand the solution

        third time to do it right 

            koide

            The key part here is that you shouldn't be afraid of throwing parts (or even throwing wholes) away. Many times we get too attached to solutions to the wrong problem because that's what we built.
```

[42 things I learned from building a production database](https://maheshba.bitbucket.io/blog/2021/10/19/42Things.html)

[136 facts every web dev should know before they burn out and turn to landscape painting or nude modelling](https://www.baldurbjarnason.com/2021/100-things-every-web-developer-should-know/)

https://news.ycombinator.com/item?id=27418296

The difference between a decent developer and a great developer is the latter understand how their work fits into the larger picture. As a result they're able to quickly and effectively pivot to suit the dynamic needs of the business. 

 It's not easy to do things the simple way, being clever is the easy path. Knowing when you need to be clever and when simple is enough is what separates experience from greenhorns. 

[20 Things I’ve Learned in my 20 Years as a Software Engineer](https://www.simplethread.com/20-things-ive-learned-in-my-20-years-as-a-software-engineer/) - [Hacker News discussion](https://news.ycombinator.com/item?id=28797485)

- The benefit of talented engineers comes from the fact that they avoid costly pitfalls - not that they pump out more code per hour worked.

The first one was not a bad person by any means, but had no social skills, no ability to communicate and often just forged ahead building great stuff on his own. Entire areas of the software were entirely conceived and created by him, and it was difficult to even grasp what he was doing while pair programming with him. In a day he would write more tests and get more coverage than the rest of us would create in a week.

The second one had come from a FAANG-ish place where he was extremely successful, but didn't want the money or stress. He was extremely kind, considerate and great at communicating. Pair programming with him was a joy and he helped everyone else on the team grow. I'm confident he could have created entire regions of the software on his own, but he knew that wasn't the right thing to do. He would often ask questions until someone else on the team could solve a problem, even though I'm sure he knew how to solve it easily himself. 

[How to Become a Bad Developer](https://rafaelquintanilha.com/how-to-become-a-bad-developer/) - [Hacker News discussion](https://news.ycombinator.com/item?id=27539342)

[An incomplete list of skills senior engineers need, beyond coding](https://skamille.medium.com/an-incomplete-list-of-skills-senior-engineers-need-beyond-coding-8ed4a521b29f)

[10 Years of Open-Source Visualization](https://observablehq.com/@mbostock/10-years-of-open-source-visualization)

[Things I Learnt from a Senior Software Engineer - Neil Kakkar](https://neilkakkar.com/things-I-learnt-from-a-senior-dev.html)

[The Marks of a True Senior Developer](https://medium.com/madhash/the-marks-of-a-true-senior-developer-d5f3b11c3375)

> “The mediocre teacher tells. The good teacher explains. The superior teacher demonstrates. The great teacher inspires.” — William Arthur Ward

[The Mistakes I Made As a Beginner Programmer](https://medium.com/edge-coders/the-mistakes-i-made-as-a-beginner-programmer-ac8b3e54c312)

[Notes to a Young Software Engineer](https://nemil.com/on-software-engineering/)

- [Think in Tradeoffs](https://nemil.com/2019/06/30/think-in-tradeoffs/) -  most engineedering decisions as tradeoffs — not good choices versus bad choices.
- [Pierce the Abstraction Wall](https://nemil.com/2019/07/30/pierce-the-abstraction-wall/) - soft versus hard interfaces
- [Don't Write Code](https://nemil.com/2020/01/10/dont-write-code/)
- [Read Code](https://nemil.com/2019/04/16/read-code/)
- [The User is King (And Not)](https://nemil.com/2020/01/29/the-user-is-king-and-not/)

[The Differences Between a Junior, Mid-Level, and Senior Developer](https://medium.com/better-programming/the-differences-between-a-junior-mid-level-and-senior-developer-bb2cb2eb000d)

[What Separates Good from Great Data Scientists?](https://towardsdatascience.com/what-separates-good-from-great-data-scientists-2906431455fd)

- strong focus on business impact,
- software engineering skills,
- expectation management,
- can use the cloud,

[Building a data team at a mid-stage startup: a short story](https://erikbern.com/2021/07/07/the-data-team-a-short-story.html)

- not aligned on metrics,
- data science work not production ready - not integrated often enough (should be like commits, early + often)
- the most basic foundation of what is most critically needed: all the important data, in the same place, easily queryable
- centralization of the reporting structure, but keeping the work management decentralized - > creates a much tighter feedback loop between data and decisions

```
    Lack of data, and fragmented data
        The product is poorly instrumented so data often doesn't exist in the first place
        A fragmentation of data systems, with data spread out over many different ones
        Brittle business processes driven by data but with little or no automation
    An unclear expectation of what the data team's job is supposed to be
        Data scientists hired to do R&D and figure out some way to deploy AI or whatever — as a result not having any clear business goal
        Data team complaining about it being hard to productionize ML, yet the product team doesn't really seem to care about the feature
        People in need of “English-to-SQL translators”
    A product team not trained to be data driven
        Product managers not thinking about data as a tool for building better features
        A lack of alignment between what product teams want to build versus what data teams have
    A culture that fundamentally is at odds with being data driven
        A culture of celebrating shipping, versus celebrating measurable progress and learnings
        To the extent teams actually use metrics, they are inconsistent, poorly measured, and in some cases at conflict with other teams
    No data leadership
        A fractured data org with various data people reporting into other functional areas
        Other departments not getting the help they need, so they work around the data team and hire lots of analysts
        Lack of standardizations of toolchain and best practice
```

```
The other thing is, note what's happening with the supply chain team. The journey is roughly:

    That team started out with their own “business analysts” (outside the data team) but need the data team to run queries for them to get data
    Those business analysts are starting to run queries themselves with the help of the data team
    They start to build up “shadow tech debt” (in this case monster SQL queries) which first causes a bunch of friction with the data team
    The data team starts embedding into the team and helping them get to a better place
    Because of the embedding, the need for business analysts goes down and data scientists goes up
```


## [What I’ve Learned in 45 Years in the Software Industry](https://www.bti360.com/what-ive-learned-in-45-years-in-the-software-industry/)

- beware the curse of knowledge
- simplicity
- understand, then be understood
- beware of technology lock in


## [12 Things I Learned During My First Year as a Machine Learning Engineer](https://towardsdatascience.com/12-things-i-learned-during-my-first-year-as-a-machine-learning-engineer-2991573a9195)

- It’s always about the data
- Communication problems are harder

Two gaps in ML
- going from course work to project work
- going from a notebook to production

Toy problem first

## [Coding Mistakes I Made As A Junior Developer](https://towardsdatascience.com/coding-mistakes-i-made-as-a-junior-developer-e151dd3b3c7d)

## 150 Successful Machine Learning Models: 6 Lessons Learned at Booking.com - [paper](https://dl.acm.org/doi/pdf/10.1145/3292500.3330744) - [blog post](https://blog.acolyer.org/2019/10/07/150-successful-machine-learning-models/)

Model performance != business performance


## [8-Bits of Advice for New Programmers (The stuff they don't teach you in school!)](https://www.youtube.com/watch?v=vVRCJ52g5m4)

- be realistic - learn variables & arithmetic, sequences, loops, arrays, functions, structures, classes
- right tools
- have fun
- practice
- rewrite - even if you are copying it over


## [7 absolute truths I unlearned as junior developer](https://monicalent.com/blog/2019/06/03/absolute-truths-unlearned-as-junior-developer/)

Not all experience is created equal
- that’s why mentors are so important, and the team you work with is worth so much more than a couple bucks in your paycheck

Loads of companies and startups have little or no tests. 
- no company has a perfect tech setup.
- being overly opinionated on topics you lack real-world experience with is pretty arrogant.
- good enough is good enough.

Documentation lies sometimes.
- focus on automation over documentation where appropriate. 

Disorganized or messy code isn’t the same as technical debt.
- Having some technical debt is healthy
- If you think your codebase is free of technical debt, there is a good chance you’re over-emphasizing polish instead of delivery. And boy did I do that!


## [How I Became a Better Programmer](https://jlongster.com/How-I-Became-Better-Programmer)

If anything, just try a new language - Regardless of what you do, you really should explore other languages. I would recommend any of the following: Clojure, Rust, Elm, OCaml/Reason, Go, or Scheme. All of them have unique features and will force you to learn a new way of thinking.


## [An Old Hacker's Tips On Staying Employed](https://madned.substack.com/p/an-old-hackers-tips-on-staying-employed)

### Personal brand

Importance of a personal brand for job security
- can be independent of the success of the projects you work on

If you were a complete pain-in-the-ass to work with, dropped the ball a lot, said things you were going to do but didn’t do them, then good luck.

### Make your boss afraid

Make yourself indispensable

### Make your boss happy

Make your boss successful

### Do it anyway

Sometimes you need to do grunt or non-glamarous work
- just get it done

> We are all constantly measured in the eyes of our employers by what we actually deliver, and those who can find a way to succeed even in the face of adversity will always have an advantage over those who cannot, or do not want to.

### Two and done

So the Two-And-Done rule was born, wherein I will state my case the first time, and if whoever is arguing to the contrary does not agree after hearing my position, I’ll let it go. 

But the next time the opportunity comes up, I will argue my point again. Maybe allowing for a gap of time for people to consider my original point, or maybe allowing me time to refine and rephrase my ideas to be more convincing.

If I fail to get my way after the second time though, I am done.
