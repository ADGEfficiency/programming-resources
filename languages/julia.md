`?` help

`;` shell

`]` package mode

`#` comments

single and double string macros

include, using, import

[Kelly Shen: Julia for Pythonistas | PyData New York 2019](https://www.youtube.com/watch?v=cjIS6O3EVGc)

[Building a constraint solver in Julia](https://opensourc.es/blog/constraint-solver-1/)

[The Unreasonable Effectiveness of Multiple Dispatch | Stefan Karpinski](https://youtu.be/kc9HwsxE1OY)

[The unreasonable effectiveness of the Julia programming language](https://arstechnica.com/science/2020/10/the-unreasonable-effectiveness-of-the-julia-programming-language/)

[What's bad about Julia?](https://viralinstruction.com/posts/badjulia/#whats_bad_about_julia)

[Jula - Algorithms Book](https://algorithmsbook.com/files/appendix-g.pdf)

[A quick introduction to data parallelism in Julia | Hacker News](https://news.ycombinator.com/item?id=24700436)

[Where we are headed and why it looks a lot like Julia (but not exactly like Julia)](https://dev-discuss.pytorch.org/t/where-we-are-headed-and-why-it-looks-a-lot-like-julia-but-not-exactly-like-julia/276) - [Hacker News](https://news.ycombinator.com/item?id=29354474)

Julia says:

    A language must compile to efficient code, and we will add restrictions to the language (type stability) to make sure this is possible.
    A language must allow post facto extensibility (multiple dispatch), and we will organize the ecosystem around JIT compilation to make this possible.
    The combination of these two features gives you a system that has dynamic language level flexibility (because you have extensibility) but static language level performance (because you have efficient code)
